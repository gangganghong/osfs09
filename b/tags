!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ALT_L	./include/keyboard.h	48;"	d
ALT_R	./include/keyboard.h	49;"	d
ANY	./include/const.h	127;"	d
APPS	./include/keyboard.h	41;"	d
ARDStruct	./boot/loader.asm	/^ARDStruct		equ	BaseOfLoaderPhyAddr + _ARDStruct$/;"	d
ASM	./Makefile	/^ASM		= nasm$/;"	m
ASMBFLAGS	./Makefile	/^ASMBFLAGS	= -I boot\/include\/$/;"	m
ASMKFLAGS	./Makefile	/^ASMKFLAGS	= -I include\/ -f elf$/;"	m
ASSERT	./include/const.h	12;"	d
ATA_IDENTIFY	./include/hd.h	257;"	d
ATA_READ	./include/hd.h	258;"	d
ATA_WRITE	./include/hd.h	259;"	d
AT_WINI_IRQ	./include/const.h	116;"	d
BACKSPACE	./include/keyboard.h	37;"	d
BLACK	./include/const.h	40;"	d
BLUE	./include/const.h	44;"	d
BOTH	./include/const.h	136;"	d
BRIGHT	./include/const.h	46;"	d
BUF	./include/const.h	174;"	d
BaseOfStack	./boot/boot.asm	/^BaseOfStack		equ	0100h	; 调试状态下堆栈基地址(栈底, 从这个位置向低地址生长)$/;"	d
BaseOfStack	./boot/boot.asm	/^BaseOfStack		equ	07c00h	; Boot状态下堆栈基地址(栈底, 从这个位置向低地址生长)$/;"	d
BaseOfStack	./boot/loader.asm	/^BaseOfStack	equ	0100h$/;"	d
BootMessage	./boot/boot.asm	/^BootMessage:		db	"Booting  "; 9字节, 不够则用空格补齐. 序号 0$/;"	d
CAPS_LOCK	./include/keyboard.h	52;"	d
CASCADE_IRQ	./include/const.h	109;"	d
CC	./Makefile	/^CC		= gcc$/;"	m
CFLAGS	./Makefile	/^CFLAGS		= -I include\/ -c -fno-builtin -Wall$/;"	m
CLOCK_IRQ	./include/const.h	107;"	d
CNT	./include/const.h	169;"	d
CONSOLE	./include/console.h	/^}CONSOLE;$/;"	t	typeref:struct:s_console
CRTC_ADDR_REG	./include/const.h	96;"	d
CRTC_DATA_REG	./include/const.h	97;"	d
CTRL_L	./include/keyboard.h	46;"	d
CTRL_R	./include/keyboard.h	47;"	d
CURSOR_H	./include/const.h	100;"	d
CURSOR_L	./include/const.h	101;"	d
DASM	./Makefile	/^DASM		= objdump$/;"	m
DASMFLAGS	./Makefile	/^DASMFLAGS	= -D$/;"	m
DASMOUTPUT	./Makefile	/^DASMOUTPUT	= kernel.bin.asm$/;"	m
DA_32	./include/protect.h	93;"	d
DA_386CGate	./include/protect.h	111;"	d
DA_386IGate	./include/protect.h	112;"	d
DA_386TGate	./include/protect.h	113;"	d
DA_386TSS	./include/protect.h	110;"	d
DA_C	./include/protect.h	103;"	d
DA_CCO	./include/protect.h	105;"	d
DA_CCOR	./include/protect.h	106;"	d
DA_CR	./include/protect.h	104;"	d
DA_DPL0	./include/protect.h	95;"	d
DA_DPL1	./include/protect.h	96;"	d
DA_DPL2	./include/protect.h	97;"	d
DA_DPL3	./include/protect.h	98;"	d
DA_DR	./include/protect.h	100;"	d
DA_DRW	./include/protect.h	101;"	d
DA_DRWA	./include/protect.h	102;"	d
DA_LDT	./include/protect.h	108;"	d
DA_LIMIT_4K	./include/protect.h	94;"	d
DA_TaskGate	./include/protect.h	109;"	d
DEFAULT_CHAR_COLOR	./include/console.h	27;"	d
DELETE	./include/keyboard.h	74;"	d
DEVICE	./include/const.h	172;"	d
DEV_CDROM	./include/const.h	201;"	d
DEV_CHAR_TTY	./include/const.h	203;"	d
DEV_CLOSE	./include/const.h	/^	DEV_CLOSE,$/;"	e	enum:msgtype
DEV_FLOPPY	./include/const.h	200;"	d
DEV_HD	./include/const.h	202;"	d
DEV_IOCTL	./include/const.h	/^	DEV_IOCTL$/;"	e	enum:msgtype
DEV_OPEN	./include/const.h	/^	DEV_OPEN = 1001,$/;"	e	enum:msgtype
DEV_READ	./include/const.h	/^	DEV_READ,$/;"	e	enum:msgtype
DEV_SCSI	./include/const.h	204;"	d
DEV_WRITE	./include/const.h	/^	DEV_WRITE,$/;"	e	enum:msgtype
DIOCTL_GET_GEO	./include/const.h	191;"	d
DOWN	./include/keyboard.h	80;"	d
DRV_OF_DEV	./kernel/hd.c	39;"	d	file:
DispAL	./boot/loader.asm	/^DispAL:$/;"	l
DispInt	./boot/loader.asm	/^DispInt:$/;"	l
DispMemInfo	./boot/loader.asm	/^DispMemInfo:$/;"	l
DispReturn	./boot/loader.asm	/^DispReturn:$/;"	l
DispStr	./boot/boot.asm	/^DispStr:$/;"	l
DispStr	./boot/loader.asm	/^DispStr:$/;"	l
DispStrRealMode	./boot/loader.asm	/^DispStrRealMode:$/;"	l
END	./include/keyboard.h	76;"	d
ENTER	./include/keyboard.h	36;"	d
ENTRYOFFSET	./Makefile	/^ENTRYOFFSET	=   0x400$/;"	m
ENTRYPOINT	./Makefile	/^ENTRYPOINT	= 0x30400$/;"	m
ESC	./include/keyboard.h	34;"	d
ETHER_IRQ	./include/const.h	110;"	d
EXTERN	./include/const.h	22;"	d
EXTERN	./include/global.h	10;"	d
EXTERN	./include/global.h	11;"	d
EXT_PART	./include/const.h	244;"	d
F1	./include/keyboard.h	57;"	d
F10	./include/keyboard.h	66;"	d
F11	./include/keyboard.h	67;"	d
F12	./include/keyboard.h	68;"	d
F2	./include/keyboard.h	58;"	d
F3	./include/keyboard.h	59;"	d
F4	./include/keyboard.h	60;"	d
F5	./include/keyboard.h	61;"	d
F6	./include/keyboard.h	62;"	d
F7	./include/keyboard.h	63;"	d
F8	./include/keyboard.h	64;"	d
F9	./include/keyboard.h	65;"	d
FIRST_PROC	./include/proc.h	80;"	d
FLAG_ALT_L	./include/keyboard.h	25;"	d
FLAG_ALT_R	./include/keyboard.h	26;"	d
FLAG_BREAK	./include/keyboard.h	19;"	d
FLAG_CTRL_L	./include/keyboard.h	23;"	d
FLAG_CTRL_R	./include/keyboard.h	24;"	d
FLAG_EXT	./include/keyboard.h	20;"	d
FLAG_PAD	./include/keyboard.h	27;"	d
FLAG_SHIFT_L	./include/keyboard.h	21;"	d
FLAG_SHIFT_R	./include/keyboard.h	22;"	d
FLASH	./include/const.h	45;"	d
FLOPPY_IRQ	./include/const.h	114;"	d
FSBUF_SIZE	./kernel/global.c	/^PUBLIC	const int	FSBUF_SIZE	= 0x100000;$/;"	v
GDT_SIZE	./include/const.h	50;"	d
GET_TICKS	./include/const.h	/^	GET_TICKS,$/;"	e	enum:msgtype
GLOBAL_VARIABLES_HERE	./kernel/global.c	8;"	d	file:
GRAY_CHAR	./include/console.h	28;"	d
GREEN	./include/const.h	43;"	d
GUI_L	./include/keyboard.h	39;"	d
GUI_R	./include/keyboard.h	40;"	d
GdtLen	./boot/loader.asm	/^GdtLen		equ	$ - LABEL_GDT$/;"	d
GdtPtr	./boot/loader.asm	/^GdtPtr		dw	GdtLen - 1				; 段界限$/;"	d
GetFATEntry	./boot/boot.asm	/^GetFATEntry:$/;"	l
GetFATEntry	./boot/loader.asm	/^GetFATEntry:$/;"	l
HARD_INT	./include/const.h	/^	HARD_INT = 1,$/;"	e	enum:msgtype
HD_TIMEOUT	./include/hd.h	255;"	d
HOME	./include/keyboard.h	75;"	d
HZ	./include/const.h	82;"	d
IDT_SIZE	./include/const.h	51;"	d
INDEX_DUMMY	./include/protect.h	68;"	d
INDEX_FLAT_C	./include/protect.h	69;"	d
INDEX_FLAT_RW	./include/protect.h	70;"	d
INDEX_LDT_C	./include/protect.h	89;"	d
INDEX_LDT_FIRST	./include/protect.h	73;"	d
INDEX_LDT_RW	./include/protect.h	90;"	d
INDEX_TSS	./include/protect.h	72;"	d
INDEX_VIDEO	./include/protect.h	71;"	d
INODE_SIZE	./include/fs.h	144;"	d
INSERT	./include/keyboard.h	73;"	d
INTERRUPT	./include/const.h	121;"	d
INT_M_CTL	./include/const.h	70;"	d
INT_M_CTLMASK	./include/const.h	71;"	d
INT_S_CTL	./include/const.h	72;"	d
INT_S_CTLMASK	./include/const.h	73;"	d
INT_VECTOR_BOUNDS	./include/protect.h	133;"	d
INT_VECTOR_BREAKPOINT	./include/protect.h	131;"	d
INT_VECTOR_COPROC_ERR	./include/protect.h	143;"	d
INT_VECTOR_COPROC_NOT	./include/protect.h	135;"	d
INT_VECTOR_COPROC_SEG	./include/protect.h	137;"	d
INT_VECTOR_DEBUG	./include/protect.h	129;"	d
INT_VECTOR_DIVIDE	./include/protect.h	128;"	d
INT_VECTOR_DOUBLE_FAULT	./include/protect.h	136;"	d
INT_VECTOR_INVAL_OP	./include/protect.h	134;"	d
INT_VECTOR_INVAL_TSS	./include/protect.h	138;"	d
INT_VECTOR_IRQ0	./include/protect.h	146;"	d
INT_VECTOR_IRQ8	./include/protect.h	147;"	d
INT_VECTOR_NMI	./include/protect.h	130;"	d
INT_VECTOR_OVERFLOW	./include/protect.h	132;"	d
INT_VECTOR_PAGE_FAULT	./include/protect.h	142;"	d
INT_VECTOR_PROTECTION	./include/protect.h	141;"	d
INT_VECTOR_SEG_NOT	./include/protect.h	139;"	d
INT_VECTOR_STACK_FAULT	./include/protect.h	140;"	d
INT_VECTOR_SYS_CALL	./include/protect.h	150;"	d
INT_VECTOR_SYS_CALL	./kernel/syscall.asm	/^INT_VECTOR_SYS_CALL equ 0x90$/;"	d
INVALID_DRIVER	./include/const.h	120;"	d
INVALID_INODE	./include/const.h	214;"	d
I_BLOCK_SPECIAL	./include/const.h	255;"	d
I_CHAR_SPECIAL	./include/const.h	257;"	d
I_DIRECTORY	./include/const.h	256;"	d
I_NAMED_PIPE	./include/const.h	258;"	d
I_REGULAR	./include/const.h	254;"	d
I_TYPE_MASK	./include/const.h	253;"	d
InitKernel	./boot/loader.asm	/^InitKernel:	; 遍历每一个 Program Header，根据 Program Header 中的信息来确定把什么放进内存，放到什么位置，以及放多少。$/;"	l
KB_ACK	./include/const.h	93;"	d
KB_CMD	./include/const.h	89;"	d
KB_DATA	./include/const.h	86;"	d
KB_INPUT	./include/keyboard.h	/^}KB_INPUT;$/;"	t	typeref:struct:s_kb
KB_IN_BYTES	./include/keyboard.h	15;"	d
KEYBOARD_IRQ	./include/const.h	108;"	d
KernelFileName	./boot/loader.asm	/^KernelFileName		db	"KERNEL  BIN", 0	; KERNEL.BIN 之文件名$/;"	d
KillMotor	./boot/loader.asm	/^KillMotor:$/;"	l
LABEL_CMP_FILENAME	./boot/boot.asm	/^LABEL_CMP_FILENAME:$/;"	l
LABEL_CMP_FILENAME	./boot/loader.asm	/^LABEL_CMP_FILENAME:$/;"	l
LABEL_DATA	./boot/loader.asm	/^LABEL_DATA:$/;"	l
LABEL_DESC_FLAT_C	./boot/loader.asm	/^LABEL_DESC_FLAT_C:		Descriptor             0,              0fffffh, DA_CR  | DA_32 | DA_LIMIT_4K			; 0 ~ 4G$/;"	l
LABEL_DESC_FLAT_RW	./boot/loader.asm	/^LABEL_DESC_FLAT_RW:		Descriptor             0,              0fffffh, DA_DRW | DA_32 | DA_LIMIT_4K			; 0 ~ 4G$/;"	l
LABEL_DESC_VIDEO	./boot/loader.asm	/^LABEL_DESC_VIDEO:		Descriptor	 0B8000h,               0ffffh, DA_DRW                         | DA_DPL3	; 显存首地址$/;"	l
LABEL_DIFFERENT	./boot/boot.asm	/^LABEL_DIFFERENT:$/;"	l
LABEL_DIFFERENT	./boot/loader.asm	/^LABEL_DIFFERENT:$/;"	l
LABEL_EVEN_2	./boot/boot.asm	/^LABEL_EVEN_2:$/;"	l
LABEL_EVEN_2	./boot/loader.asm	/^LABEL_EVEN_2:$/;"	l
LABEL_FILENAME_FOUND	./boot/boot.asm	/^LABEL_FILENAME_FOUND:			; 找到 LOADER.BIN 后便来到这里继续$/;"	l
LABEL_FILENAME_FOUND	./boot/loader.asm	/^LABEL_FILENAME_FOUND:			; 找到 KERNEL.BIN 后便来到这里继续$/;"	l
LABEL_FILE_LOADED	./boot/boot.asm	/^LABEL_FILE_LOADED:$/;"	l
LABEL_FILE_LOADED	./boot/loader.asm	/^LABEL_FILE_LOADED:$/;"	l
LABEL_GDT	./boot/loader.asm	/^LABEL_GDT:			Descriptor             0,                    0, 0						; 空描述符$/;"	l
LABEL_GET_FAT_ENRY_OK	./boot/boot.asm	/^LABEL_GET_FAT_ENRY_OK:$/;"	l
LABEL_GET_FAT_ENRY_OK	./boot/loader.asm	/^LABEL_GET_FAT_ENRY_OK:$/;"	l
LABEL_GOON_LOADING_FILE	./boot/boot.asm	/^LABEL_GOON_LOADING_FILE:$/;"	l
LABEL_GOON_LOADING_FILE	./boot/loader.asm	/^LABEL_GOON_LOADING_FILE:$/;"	l
LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR	./boot/boot.asm	/^LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR:$/;"	l
LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR	./boot/loader.asm	/^LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR:$/;"	l
LABEL_GO_ON	./boot/boot.asm	/^LABEL_GO_ON:$/;"	l
LABEL_GO_ON	./boot/loader.asm	/^LABEL_GO_ON:$/;"	l
LABEL_NO_KERNELBIN	./boot/loader.asm	/^LABEL_NO_KERNELBIN:$/;"	l
LABEL_NO_LOADERBIN	./boot/boot.asm	/^LABEL_NO_LOADERBIN:$/;"	l
LABEL_PM_START	./boot/loader.asm	/^LABEL_PM_START:$/;"	l
LABEL_SEARCH_FOR_KERNELBIN	./boot/loader.asm	/^LABEL_SEARCH_FOR_KERNELBIN:$/;"	l
LABEL_SEARCH_FOR_LOADERBIN	./boot/boot.asm	/^LABEL_SEARCH_FOR_LOADERBIN:$/;"	l
LABEL_SEARCH_IN_ROOT_DIR_BEGIN	./boot/boot.asm	/^LABEL_SEARCH_IN_ROOT_DIR_BEGIN:$/;"	l
LABEL_SEARCH_IN_ROOT_DIR_BEGIN	./boot/loader.asm	/^LABEL_SEARCH_IN_ROOT_DIR_BEGIN:$/;"	l
LABEL_START	./boot/boot.asm	/^LABEL_START:	$/;"	l
LABEL_START	./boot/loader.asm	/^LABEL_START:			; <--- 从这里开始 *************$/;"	l
LAST_PROC	./include/proc.h	81;"	d
LD	./Makefile	/^LD		= ld$/;"	m
LDFLAGS	./Makefile	/^LDFLAGS		= -Ttext $(ENTRYPOINT) -Map krnl.map$/;"	m
LDT_SIZE	./include/protect.h	87;"	d
LED_CODE	./include/const.h	92;"	d
LEFT	./include/keyboard.h	81;"	d
LoadMessage	./boot/loader.asm	/^LoadMessage:		db	"Loading  "$/;"	d
LoaderFileName	./boot/boot.asm	/^LoaderFileName		db	"LOADER  BIN", 0	; LOADER.BIN 之文件名$/;"	d
MAGIC_V1	./include/fs.h	35;"	d
MAG_CH_ASSERT	./include/const.h	140;"	d
MAG_CH_PANIC	./include/const.h	139;"	d
MAJOR	./include/const.h	211;"	d
MAJOR_SHIFT	./include/const.h	207;"	d
MAKE_COLOR	./include/const.h	47;"	d
MAKE_DEV	./include/const.h	208;"	d
MAKE_DEVICE_REG	./include/hd.h	261;"	d
MAP_COLS	./include/keyboard.h	16;"	d
MASK_RAW	./include/keyboard.h	29;"	d
MAX_DRIVES	./include/const.h	217;"	d
MAX_PRIM	./include/const.h	229;"	d
MAX_SUBPARTITIONS	./include/const.h	231;"	d
MESSAGE	./include/type.h	/^} MESSAGE;$/;"	t	typeref:struct:__anon1
MINOR	./include/const.h	212;"	d
MINOR_BOOT	./include/config.h	10;"	d
MINOR_hd1a	./include/const.h	234;"	d
MINOR_hd2a	./include/const.h	235;"	d
MemChkBuf	./boot/loader.asm	/^MemChkBuf		equ	BaseOfLoaderPhyAddr + _MemChkBuf$/;"	d
MemCpy	./boot/loader.asm	/^MemCpy:$/;"	l
Message1	./boot/boot.asm	/^Message1		db	"Ready.   "; 9字节, 不够则用空格补齐. 序号 1$/;"	d
Message1	./boot/loader.asm	/^Message1		db	"Ready.   "$/;"	d
Message2	./boot/boot.asm	/^Message2		db	"No LOADER"; 9字节, 不够则用空格补齐. 序号 2$/;"	d
Message2	./boot/loader.asm	/^Message2		db	"No KERNEL"$/;"	d
MessageLength	./boot/boot.asm	/^MessageLength		equ	9$/;"	d
MessageLength	./boot/loader.asm	/^MessageLength		equ	9$/;"	d
NO_DEV	./include/const.h	199;"	d
NO_PART	./include/const.h	243;"	d
NO_TASK	./include/const.h	128;"	d
NR_CONSOLES	./include/const.h	67;"	d
NR_DEFAULT_FILE_SECTS	./include/const.h	263;"	d
NR_FILES	./include/const.h	246;"	d
NR_FILE_DESC	./include/const.h	247;"	d
NR_INODE	./include/const.h	248;"	d
NR_IRQ	./include/const.h	106;"	d
NR_PART_PER_DRIVE	./include/const.h	218;"	d
NR_PRIM_PER_DRIVE	./include/const.h	221;"	d
NR_PROCS	./include/proc.h	79;"	d
NR_SCAN_CODES	./include/keyboard.h	17;"	d
NR_SUB_PER_DRIVE	./include/const.h	220;"	d
NR_SUB_PER_PART	./include/const.h	219;"	d
NR_SUPER_BLOCK	./include/const.h	249;"	d
NR_SYS_CALL	./include/const.h	131;"	d
NR_TASKS	./include/proc.h	78;"	d
NUM_LOCK	./include/keyboard.h	53;"	d
OBJS	./Makefile	/^OBJS		= kernel\/kernel.o kernel\/syscall.o kernel\/start.o kernel\/main.o\\$/;"	m
ORANGESBOOT	./Makefile	/^ORANGESBOOT	= boot\/boot.bin boot\/loader.bin$/;"	m
ORANGESKERNEL	./Makefile	/^ORANGESKERNEL	= kernel.bin$/;"	m
ORANGES_PART	./include/const.h	242;"	d
PAD_0	./include/keyboard.h	96;"	d
PAD_1	./include/keyboard.h	97;"	d
PAD_2	./include/keyboard.h	98;"	d
PAD_3	./include/keyboard.h	99;"	d
PAD_4	./include/keyboard.h	100;"	d
PAD_5	./include/keyboard.h	101;"	d
PAD_6	./include/keyboard.h	102;"	d
PAD_7	./include/keyboard.h	103;"	d
PAD_8	./include/keyboard.h	104;"	d
PAD_9	./include/keyboard.h	105;"	d
PAD_DEL	./include/keyboard.h	116;"	d
PAD_DOT	./include/keyboard.h	95;"	d
PAD_DOWN	./include/keyboard.h	107;"	d
PAD_END	./include/keyboard.h	111;"	d
PAD_ENTER	./include/keyboard.h	94;"	d
PAD_HOME	./include/keyboard.h	110;"	d
PAD_INS	./include/keyboard.h	114;"	d
PAD_LEFT	./include/keyboard.h	108;"	d
PAD_MID	./include/keyboard.h	115;"	d
PAD_MINUS	./include/keyboard.h	92;"	d
PAD_PAGEDOWN	./include/keyboard.h	113;"	d
PAD_PAGEUP	./include/keyboard.h	112;"	d
PAD_PLUS	./include/keyboard.h	93;"	d
PAD_RIGHT	./include/keyboard.h	109;"	d
PAD_SLASH	./include/keyboard.h	90;"	d
PAD_STAR	./include/keyboard.h	91;"	d
PAD_UP	./include/keyboard.h	106;"	d
PAGEDOWN	./include/keyboard.h	78;"	d
PAGEUP	./include/keyboard.h	77;"	d
PARTITION_ENTRY	./include/hd.h	/^} PARTITION_ENTRY;$/;"	v	typeref:struct:part_ent
PARTITION_TABLE_OFFSET	./include/hd.h	256;"	d
PAUSEBREAK	./include/keyboard.h	72;"	d
POSITION	./include/const.h	173;"	d
POWER	./include/keyboard.h	85;"	d
PRINTER_IRQ	./include/const.h	115;"	d
PRINTSCREEN	./include/keyboard.h	71;"	d
PRIVATE	./include/const.h	26;"	d
PRIVILEGE_KRNL	./include/const.h	54;"	d
PRIVILEGE_TASK	./include/const.h	55;"	d
PRIVILEGE_USER	./include/const.h	56;"	d
PROC_NR	./include/const.h	171;"	d
PUBLIC	./include/const.h	25;"	d
P_EXTENDED	./include/const.h	240;"	d
P_PRIMARY	./include/const.h	239;"	d
RATE_GENERATOR	./include/const.h	78;"	d
RD_SECT	./include/fs.h	165;"	d
RECEIVE	./include/const.h	135;"	d
RECEIVING	./include/const.h	64;"	d
RED	./include/const.h	42;"	d
RED_CHAR	./include/console.h	29;"	d
REG_ALT_STATUS	./include/hd.h	220;"	d
REG_CMD	./include/hd.h	176;"	d
REG_DATA	./include/hd.h	108;"	d
REG_DEVICE	./include/hd.h	134;"	d
REG_DEV_CTRL	./include/hd.h	200;"	d
REG_DRV_ADDR	./include/hd.h	225;"	d
REG_ERROR	./include/hd.h	110;"	d
REG_FEATURES	./include/hd.h	109;"	d
REG_LBA_HIGH	./include/hd.h	133;"	d
REG_LBA_LOW	./include/hd.h	131;"	d
REG_LBA_MID	./include/hd.h	132;"	d
REG_NSECTOR	./include/hd.h	130;"	d
REG_STATUS	./include/hd.h	151;"	d
REQUEST	./include/const.h	170;"	d
RETVAL	./include/const.h	180;"	d
RIGHT	./include/keyboard.h	82;"	d
ROOT_DEV	./include/const.h	237;"	d
ROOT_INODE	./include/const.h	215;"	d
RPL_KRNL	./include/const.h	58;"	d
RPL_TASK	./include/const.h	59;"	d
RPL_USER	./include/const.h	60;"	d
RS232_IRQ	./include/const.h	112;"	d
ReadSector	./boot/boot.asm	/^ReadSector:$/;"	l
ReadSector	./boot/loader.asm	/^ReadSector:$/;"	l
SA_RPL0	./include/protect.h	118;"	d
SA_RPL1	./include/protect.h	119;"	d
SA_RPL2	./include/protect.h	120;"	d
SA_RPL3	./include/protect.h	121;"	d
SA_RPL_MASK	./include/protect.h	117;"	d
SA_TIG	./include/protect.h	124;"	d
SA_TIL	./include/protect.h	125;"	d
SA_TI_MASK	./include/protect.h	123;"	d
SCROLL_LOCK	./include/keyboard.h	54;"	d
SCR_DN	./include/console.h	22;"	d
SCR_SIZE	./include/console.h	24;"	d
SCR_UP	./include/console.h	21;"	d
SCR_WIDTH	./include/console.h	25;"	d
SECONDARY_IRQ	./include/const.h	111;"	d
SECTOR_BITS	./include/const.h	195;"	d
SECTOR_SIZE	./include/const.h	194;"	d
SECTOR_SIZE_SHIFT	./include/const.h	196;"	d
SELECTOR_DUMMY	./include/protect.h	75;"	d
SELECTOR_FLAT_C	./include/protect.h	76;"	d
SELECTOR_FLAT_RW	./include/protect.h	77;"	d
SELECTOR_KERNEL_CS	./include/protect.h	82;"	d
SELECTOR_KERNEL_DS	./include/protect.h	83;"	d
SELECTOR_KERNEL_GS	./include/protect.h	84;"	d
SELECTOR_LDT_FIRST	./include/protect.h	80;"	d
SELECTOR_TSS	./include/protect.h	79;"	d
SELECTOR_VIDEO	./include/protect.h	78;"	d
SEND	./include/const.h	134;"	d
SENDING	./include/const.h	63;"	d
SHIFT_L	./include/keyboard.h	44;"	d
SHIFT_R	./include/keyboard.h	45;"	d
SLEEP	./include/keyboard.h	86;"	d
STACK_SIZE_FS	./include/proc.h	87;"	d
STACK_SIZE_HD	./include/proc.h	86;"	d
STACK_SIZE_SYS	./include/proc.h	85;"	d
STACK_SIZE_TESTA	./include/proc.h	88;"	d
STACK_SIZE_TESTB	./include/proc.h	89;"	d
STACK_SIZE_TESTC	./include/proc.h	90;"	d
STACK_SIZE_TOTAL	./include/proc.h	92;"	d
STACK_SIZE_TTY	./include/proc.h	84;"	d
START_ADDR_H	./include/const.h	98;"	d
START_ADDR_L	./include/const.h	99;"	d
STATUS_BSY	./include/hd.h	167;"	d
STATUS_CORR	./include/hd.h	172;"	d
STATUS_DFSE	./include/hd.h	169;"	d
STATUS_DRDY	./include/hd.h	168;"	d
STATUS_DRQ	./include/hd.h	171;"	d
STATUS_DSC	./include/hd.h	170;"	d
STATUS_ERR	./include/hd.h	174;"	d
STATUS_IDX	./include/hd.h	173;"	d
STR_DEFAULT_LEN	./include/const.h	28;"	d
SUPER_BLK_MAGIC_V1	./include/fs.h	97;"	d
SUPER_BLOCK_SIZE	./include/fs.h	106;"	d
SelectorFlatC	./boot/loader.asm	/^SelectorFlatC		equ	LABEL_DESC_FLAT_C	- LABEL_GDT$/;"	d
SelectorFlatRW	./boot/loader.asm	/^SelectorFlatRW		equ	LABEL_DESC_FLAT_RW	- LABEL_GDT$/;"	d
SelectorVideo	./boot/loader.asm	/^SelectorVideo		equ	LABEL_DESC_VIDEO	- LABEL_GDT + SA_RPL3$/;"	d
SetupPaging	./boot/loader.asm	/^SetupPaging:$/;"	l
StackSpace	./boot/loader.asm	/^StackSpace:	times	1000h	db	0$/;"	l
StackSpace	./kernel/kernel.asm	/^StackSpace		resb	2 * 1024$/;"	l
StackTop	./kernel/kernel.asm	/^StackTop:		; 栈顶$/;"	l
TAB	./include/keyboard.h	35;"	d
TASK_HD	./include/const.h	124;"	d
TASK_SYS	./include/const.h	123;"	d
TASK_TTY	./include/const.h	122;"	d
TIMER0	./include/const.h	76;"	d
TIMER_FREQ	./include/const.h	81;"	d
TIMER_MODE	./include/const.h	77;"	d
TTY	./include/tty.h	/^}TTY;$/;"	t	typeref:struct:s_tty
TTY_END	./kernel/tty.c	21;"	d	file:
TTY_FIRST	./kernel/tty.c	20;"	d	file:
TTY_IN_BYTES	./include/tty.h	12;"	d
TestA	./kernel/main.c	/^void TestA()$/;"	f
TestB	./kernel/main.c	/^void TestB()$/;"	f
TestC	./kernel/main.c	/^void TestC()$/;"	f
TopOfStack	./boot/loader.asm	/^TopOfStack	equ	BaseOfLoaderPhyAddr + $	; 栈顶$/;"	d
UP	./include/keyboard.h	79;"	d
V_MEM_BASE	./include/const.h	102;"	d
V_MEM_SIZE	./include/const.h	103;"	d
WAKE	./include/keyboard.h	87;"	d
WHITE	./include/const.h	41;"	d
WR_SECT	./include/fs.h	171;"	d
XT_WINI_IRQ	./include/const.h	113;"	d
_ARDStruct	./boot/loader.asm	/^_ARDStruct:			; Address Range Descriptor Structure$/;"	l
_MemChkBuf	./boot/loader.asm	/^_MemChkBuf:	times	256	db	0$/;"	l
_NR_printx	./kernel/syscall.asm	/^_NR_printx	    equ 0$/;"	d
_NR_sendrec	./kernel/syscall.asm	/^_NR_sendrec	    equ 1$/;"	d
_ORANGES_CONSOLE_H_	./include/console.h	9;"	d
_ORANGES_CONST_H_	./include/const.h	9;"	d
_ORANGES_FS_H_	./include/fs.h	11;"	d
_ORANGES_HD_H_	./include/hd.h	11;"	d
_ORANGES_KEYBOARD_H_	./include/keyboard.h	9;"	d
_ORANGES_KEYMAP_H_	./include/keymap.h	14;"	d
_ORANGES_PROTECT_H_	./include/protect.h	9;"	d
_ORANGES_TTY_H_	./include/tty.h	9;"	d
_ORANGES_TYPE_H_	./include/type.h	9;"	d
_dwBaseAddrHigh	./boot/loader.asm	/^	_dwBaseAddrHigh:	dd	0$/;"	d
_dwBaseAddrLow	./boot/loader.asm	/^	_dwBaseAddrLow:		dd	0$/;"	d
_dwDispPos	./boot/loader.asm	/^_dwDispPos:			dd	(80 * 6 + 0) * 2	; 屏幕第 6 行, 第 0 列。$/;"	d
_dwLengthHigh	./boot/loader.asm	/^	_dwLengthHigh:		dd	0$/;"	d
_dwLengthLow	./boot/loader.asm	/^	_dwLengthLow:		dd	0$/;"	d
_dwMCRNumber	./boot/loader.asm	/^_dwMCRNumber:			dd	0	; Memory Check Result$/;"	d
_dwMemSize	./boot/loader.asm	/^_dwMemSize:			dd	0$/;"	d
_dwType	./boot/loader.asm	/^	_dwType:		dd	0$/;"	d
_start	./kernel/kernel.asm	/^_start:$/;"	l
_szMemChkTitle	./boot/loader.asm	/^_szMemChkTitle:			db	"BaseAddrL BaseAddrH LengthLow LengthHigh   Type", 0Ah, 0$/;"	d
_szRAMSize	./boot/loader.asm	/^_szRAMSize:			db	"RAM size:", 0$/;"	d
_szReturn	./boot/loader.asm	/^_szReturn:			db	0Ah, 0$/;"	d
_unused	./include/fs.h	/^	u8	_unused[16];	\/**< Stuff for alignment *\/$/;"	m	struct:inode
alt_l	./kernel/keyboard.c	/^PRIVATE	int	alt_l;		\/* l alt state	 *\/$/;"	v
alt_r	./kernel/keyboard.c	/^PRIVATE	int	alt_r;		\/* r left state	 *\/$/;"	v
assert	./include/const.h	15;"	d
assert	./include/const.h	18;"	d
assertion_failure	./lib/misc.c	/^PUBLIC void assertion_failure(char *exp, char *file, char *base_file, int line)$/;"	f
attr	./include/protect.h	/^	u8	attr;		\/* P(1) DPL(2) DT(1) TYPE(4) *\/$/;"	m	struct:gate
attr1	./include/protect.h	/^	u8	attr1;			\/* P(1) DPL(2) DT(1) TYPE(4) *\/$/;"	m	struct:descriptor
bOdd	./boot/boot.asm	/^bOdd			db	0		; 奇数还是偶数$/;"	d
bOdd	./boot/loader.asm	/^bOdd			db	0		; 奇数还是偶数$/;"	d
backlink	./include/protect.h	/^	u32	backlink;$/;"	m	struct:tss
base	./include/hd.h	/^	u32	base;	\/* # of start sector (NOT byte offset, but SECTOR) *\/$/;"	m	struct:part_info
base_high	./include/protect.h	/^	u8	base_high;		\/* Base *\/$/;"	m	struct:descriptor
base_low	./include/protect.h	/^	u16	base_low;		\/* Base *\/$/;"	m	struct:descriptor
base_mid	./include/protect.h	/^	u8	base_mid;		\/* Base *\/$/;"	m	struct:descriptor
bits	./kernel/kernel.asm	/^bits 32$/;"	l
bits	./kernel/syscall.asm	/^bits 32$/;"	l
block	./kernel/proc.c	/^PRIVATE void block(struct proc* p)$/;"	f
boot_ind	./include/hd.h	/^	u8 boot_ind;		\/**$/;"	m	struct:part_ent
bounds_check	./kernel/kernel.asm	/^bounds_check:$/;"	l
breakpoint_exception	./kernel/kernel.asm	/^breakpoint_exception:$/;"	l
buf	./include/keyboard.h	/^	char	buf[KB_IN_BYTES];	\/* 缓冲区 *\/$/;"	m	struct:s_kb
caps_lock	./kernel/keyboard.c	/^PRIVATE	int	caps_lock;	\/* Caps Lock	 *\/$/;"	v
clock_handler	./kernel/clock.c	/^PUBLIC void clock_handler(int irq)$/;"	f
clock_int_msg	./kernel/kernel.asm	/^clock_int_msg		db	"^", 0$/;"	d
code_with_E0	./kernel/keyboard.c	/^PRIVATE	int	code_with_E0;$/;"	v
column	./kernel/keyboard.c	/^PRIVATE	int	column;$/;"	v
command	./include/hd.h	/^	u8	command;$/;"	m	struct:hd_cmd
console_table	./kernel/global.c	/^PUBLIC	CONSOLE		console_table[NR_CONSOLES];$/;"	v
copr_error	./kernel/kernel.asm	/^copr_error:$/;"	l
copr_not_available	./kernel/kernel.asm	/^copr_not_available:$/;"	l
copr_seg_overrun	./kernel/kernel.asm	/^copr_seg_overrun:$/;"	l
count	./include/hd.h	/^	u8	count;$/;"	m	struct:hd_cmd
count	./include/keyboard.h	/^	int	count;			\/* 缓冲区中共有多少字节 *\/$/;"	m	struct:s_kb
cr3	./include/protect.h	/^	u32	cr3;$/;"	m	struct:tss
cs	./include/proc.h	/^	u32	cs;		\/*  ┃						│			*\/$/;"	m	struct:stackframe
cs	./include/protect.h	/^	u32	cs;$/;"	m	struct:tss
csinit	./kernel/kernel.asm	/^csinit:		; “这个跳转指令强制使用刚刚初始化的结构”——<<OS:D&I 2nd>> P90.$/;"	l
cstart	./kernel/start.c	/^PUBLIC void cstart()$/;"	f
ctrl_l	./kernel/keyboard.c	/^PRIVATE	int	ctrl_l;		\/* l ctrl state	 *\/$/;"	v
ctrl_r	./kernel/keyboard.c	/^PRIVATE	int	ctrl_r;		\/* l ctrl state	 *\/$/;"	v
current_start_addr	./include/console.h	/^	unsigned int	current_start_addr;	\/* 当前显示到了什么位置	  *\/$/;"	m	struct:s_console
cursor	./include/console.h	/^	unsigned int	cursor;			\/* 当前光标位置 *\/$/;"	m	struct:s_console
dcount	./include/protect.h	/^	u8	dcount;		\/* 该字段只在调用门描述符中有效。$/;"	m	struct:gate
dd_map	./kernel/global.c	/^struct dev_drv_map dd_map[] = {$/;"	v	typeref:struct:dev_drv_map
deadlock	./kernel/proc.c	/^PRIVATE int deadlock(int src, int dest)$/;"	f
dec	./boot/boot.asm	/^	dec	dx					; ┛就跳到下一个 Sector$/;"	d
dec	./boot/boot.asm	/^dec	cx$/;"	l
dec	./boot/loader.asm	/^	dec	dx					; ┛$/;"	d
delay	./lib/klib.c	/^PUBLIC void delay(int time)$/;"	f
descriptor	./include/protect.h	/^struct descriptor		\/* 共 8 个字节 *\/$/;"	s
dev_drv_map	./include/fs.h	/^struct dev_drv_map {$/;"	s
device	./include/hd.h	/^	u8	device;$/;"	m	struct:hd_cmd
dir_ent_fname_off	./include/fs.h	/^	u32	dir_ent_fname_off;\/**< Offset of `struct dir_entry::name' *\/$/;"	m	struct:super_block
dir_ent_inode_off	./include/fs.h	/^	u32	dir_ent_inode_off;\/**< Offset of `struct dir_entry::inode_nr' *\/$/;"	m	struct:super_block
dir_ent_size	./include/fs.h	/^	u32	dir_ent_size;     \/**< DIR_ENTRY_SIZE *\/$/;"	m	struct:super_block
dis_already	./lib/kliba.asm	/^dis_already:$/;"	l
disable_0	./lib/kliba.asm	/^disable_0:$/;"	l
disable_8	./lib/kliba.asm	/^disable_8:$/;"	l
disable_int	./lib/kliba.asm	/^disable_int:$/;"	l
disable_irq	./lib/kliba.asm	/^disable_irq:$/;"	l
disp_color_str	./lib/kliba.asm	/^disp_color_str:$/;"	l
disp_int	./lib/klib.c	/^PUBLIC void disp_int(int input)$/;"	f
disp_pos	./include/global.h	/^EXTERN	int	disp_pos;$/;"	v
disp_str	./lib/kliba.asm	/^disp_str:$/;"	l
divide_error	./kernel/kernel.asm	/^divide_error:$/;"	l
double_fault	./kernel/kernel.asm	/^double_fault:$/;"	l
driver_nr	./include/fs.h	/^	int driver_nr; \/**< The proc nr.\\ of the device driver. *\/$/;"	m	struct:dev_drv_map
ds	./include/proc.h	/^	u32	ds;		\/* ┃						│			*\/$/;"	m	struct:stackframe
ds	./include/protect.h	/^	u32	ds;$/;"	m	struct:tss
dump_msg	./kernel/proc.c	/^PUBLIC void dump_msg(const char * title, MESSAGE* m)$/;"	f
dump_proc	./kernel/proc.c	/^PUBLIC void dump_proc(struct proc* p)$/;"	f
dw	./boot/boot.asm	/^dw 	0xaa55				; 结束标志$/;"	l
dwBaseAddrHigh	./boot/loader.asm	/^	dwBaseAddrHigh	equ	BaseOfLoaderPhyAddr + _dwBaseAddrHigh$/;"	d
dwBaseAddrLow	./boot/loader.asm	/^	dwBaseAddrLow	equ	BaseOfLoaderPhyAddr + _dwBaseAddrLow$/;"	d
dwDispPos	./boot/loader.asm	/^dwDispPos		equ	BaseOfLoaderPhyAddr + _dwDispPos$/;"	d
dwKernelSize	./boot/loader.asm	/^dwKernelSize		dd	0		; KERNEL.BIN 文件大小$/;"	d
dwLengthHigh	./boot/loader.asm	/^	dwLengthHigh	equ	BaseOfLoaderPhyAddr + _dwLengthHigh$/;"	d
dwLengthLow	./boot/loader.asm	/^	dwLengthLow	equ	BaseOfLoaderPhyAddr + _dwLengthLow$/;"	d
dwMCRNumber	./boot/loader.asm	/^dwMCRNumber		equ	BaseOfLoaderPhyAddr + _dwMCRNumber$/;"	d
dwMemSize	./boot/loader.asm	/^dwMemSize		equ	BaseOfLoaderPhyAddr + _dwMemSize$/;"	d
dwType	./boot/loader.asm	/^	dwType		equ	BaseOfLoaderPhyAddr + _dwType$/;"	d
eax	./include/proc.h	/^	u32	eax;		\/* ┛						│			*\/$/;"	m	struct:stackframe
eax	./include/protect.h	/^	u32	eax;$/;"	m	struct:tss
ebp	./include/proc.h	/^	u32	ebp;		\/* ┃						│			*\/$/;"	m	struct:stackframe
ebp	./include/protect.h	/^	u32	ebp;$/;"	m	struct:tss
ebx	./include/proc.h	/^	u32	ebx;		\/* ┃						↑栈从高地址往低地址增长*\/		$/;"	m	struct:stackframe
ebx	./include/protect.h	/^	u32	ebx;$/;"	m	struct:tss
ecx	./include/proc.h	/^	u32	ecx;		\/* ┃						│			*\/$/;"	m	struct:stackframe
ecx	./include/protect.h	/^	u32	ecx;$/;"	m	struct:tss
edi	./include/proc.h	/^	u32	edi;		\/* ┃						│			*\/$/;"	m	struct:stackframe
edi	./include/protect.h	/^	u32	edi;$/;"	m	struct:tss
edx	./include/proc.h	/^	u32	edx;		\/* ┃						│			*\/$/;"	m	struct:stackframe
edx	./include/protect.h	/^	u32	edx;$/;"	m	struct:tss
eflags	./include/proc.h	/^	u32	eflags;		\/*  ┣ these are pushed by CPU during interrupt	│			*\/$/;"	m	struct:stackframe
eip	./include/proc.h	/^	u32	eip;		\/*  ┓						│			*\/$/;"	m	struct:stackframe
eip	./include/protect.h	/^	u32	eip;$/;"	m	struct:tss
enable_0	./lib/kliba.asm	/^enable_0:$/;"	l
enable_8	./lib/kliba.asm	/^enable_8:$/;"	l
enable_int	./lib/kliba.asm	/^enable_int:$/;"	l
enable_irq	./lib/kliba.asm	/^enable_irq:$/;"	l
end_cyl	./include/hd.h	/^	u8 end_cyl;		\/**$/;"	m	struct:part_ent
end_head	./include/hd.h	/^	u8 end_head;		\/**$/;"	m	struct:part_ent
end_sector	./include/hd.h	/^	u8 end_sector;		\/**$/;"	m	struct:part_ent
es	./include/proc.h	/^	u32	es;		\/* ┃						│			*\/$/;"	m	struct:stackframe
es	./include/protect.h	/^	u32	es;$/;"	m	struct:tss
esi	./include/proc.h	/^	u32	esi;		\/* ┣ pushed by save()				│			*\/$/;"	m	struct:stackframe
esi	./include/protect.h	/^	u32	esi;$/;"	m	struct:tss
esp	./include/proc.h	/^	u32	esp;		\/*  ┃						│			*\/$/;"	m	struct:stackframe
esp	./include/protect.h	/^	u32	esp;$/;"	m	struct:tss
esp0	./include/protect.h	/^	u32	esp0;		\/* stack pointer to use during interrupt *\/$/;"	m	struct:tss
esp1	./include/protect.h	/^	u32	esp1;$/;"	m	struct:tss
esp2	./include/protect.h	/^	u32	esp2;$/;"	m	struct:tss
exception	./kernel/kernel.asm	/^exception:$/;"	l
exception_handler	./kernel/protect.c	/^PUBLIC void exception_handler(int vec_no, int err_code, int eip, int cs, int eflags)$/;"	f
extern	./kernel/kernel.asm	/^extern	clock_handler$/;"	l
extern	./kernel/kernel.asm	/^extern	cstart$/;"	l
extern	./kernel/kernel.asm	/^extern	delay$/;"	l
extern	./kernel/kernel.asm	/^extern	disp_pos$/;"	l
extern	./kernel/kernel.asm	/^extern	disp_str$/;"	l
extern	./kernel/kernel.asm	/^extern	exception_handler$/;"	l
extern	./kernel/kernel.asm	/^extern	gdt_ptr$/;"	l
extern	./kernel/kernel.asm	/^extern	idt_ptr$/;"	l
extern	./kernel/kernel.asm	/^extern	irq_table$/;"	l
extern	./kernel/kernel.asm	/^extern	k_reenter$/;"	l
extern	./kernel/kernel.asm	/^extern	kernel_main$/;"	l
extern	./kernel/kernel.asm	/^extern	p_proc_ready$/;"	l
extern	./kernel/kernel.asm	/^extern	spurious_irq$/;"	l
extern	./kernel/kernel.asm	/^extern	sys_call_table$/;"	l
extern	./kernel/kernel.asm	/^extern	tss$/;"	l
extern	./lib/kliba.asm	/^extern	disp_pos$/;"	l
fd_inode	./include/fs.h	/^	struct inode*	fd_inode;	\/**< Ptr to the i-node *\/$/;"	m	struct:file_desc	typeref:struct:file_desc::inode
fd_mode	./include/fs.h	/^	int		fd_mode;	\/**< R or W *\/$/;"	m	struct:file_desc
fd_pos	./include/fs.h	/^	int		fd_pos;		\/**< Current position for R\/W. *\/$/;"	m	struct:file_desc
features	./include/hd.h	/^	u8	features;$/;"	m	struct:hd_cmd
file_desc	./include/fs.h	/^struct file_desc {$/;"	s
flags	./include/protect.h	/^	u32	flags;$/;"	m	struct:tss
flush	./kernel/console.c	/^PRIVATE void flush(CONSOLE* p_con)$/;"	f
fs	./include/proc.h	/^	u32	fs;		\/* ┃						│			*\/$/;"	m	struct:stackframe
fs	./include/protect.h	/^	u32	fs;$/;"	m	struct:tss
fsbuf	./kernel/global.c	/^PUBLIC	u8 *		fsbuf		= (u8*)0x600000;$/;"	v
gate	./include/protect.h	/^struct gate$/;"	s
gdt	./include/global.h	/^EXTERN	struct descriptor	gdt[GDT_SIZE];$/;"	v	typeref:struct:descriptor
gdt_ptr	./include/global.h	/^EXTERN	u8			gdt_ptr[6];	\/* 0~15:Limit  16~47:Base *\/$/;"	v
general_protection	./kernel/kernel.asm	/^general_protection:$/;"	l
get_byte_from_kbuf	./kernel/keyboard.c	/^PRIVATE u8 get_byte_from_kbuf()       \/* 从键盘缓冲区中读取下一个字节 *\/$/;"	f
get_part_table	./kernel/hd.c	/^PRIVATE void get_part_table(int drive, int sect_nr, struct part_ent * entry)$/;"	f
get_ticks	./kernel/main.c	/^PUBLIC int get_ticks()$/;"	f
glitter	./lib/kliba.asm	/^glitter:$/;"	l
global	./kernel/kernel.asm	/^global	bounds_check$/;"	l
global	./kernel/kernel.asm	/^global	breakpoint_exception$/;"	l
global	./kernel/kernel.asm	/^global	copr_error$/;"	l
global	./kernel/kernel.asm	/^global	copr_not_available$/;"	l
global	./kernel/kernel.asm	/^global	copr_seg_overrun$/;"	l
global	./kernel/kernel.asm	/^global	divide_error$/;"	l
global	./kernel/kernel.asm	/^global	double_fault$/;"	l
global	./kernel/kernel.asm	/^global	general_protection$/;"	l
global	./kernel/kernel.asm	/^global	hwint00$/;"	l
global	./kernel/kernel.asm	/^global	hwint01$/;"	l
global	./kernel/kernel.asm	/^global	hwint02$/;"	l
global	./kernel/kernel.asm	/^global	hwint03$/;"	l
global	./kernel/kernel.asm	/^global	hwint04$/;"	l
global	./kernel/kernel.asm	/^global	hwint05$/;"	l
global	./kernel/kernel.asm	/^global	hwint06$/;"	l
global	./kernel/kernel.asm	/^global	hwint07$/;"	l
global	./kernel/kernel.asm	/^global	hwint08$/;"	l
global	./kernel/kernel.asm	/^global	hwint09$/;"	l
global	./kernel/kernel.asm	/^global	hwint10$/;"	l
global	./kernel/kernel.asm	/^global	hwint11$/;"	l
global	./kernel/kernel.asm	/^global	hwint12$/;"	l
global	./kernel/kernel.asm	/^global	hwint13$/;"	l
global	./kernel/kernel.asm	/^global	hwint14$/;"	l
global	./kernel/kernel.asm	/^global	hwint15$/;"	l
global	./kernel/kernel.asm	/^global	inval_opcode$/;"	l
global	./kernel/kernel.asm	/^global	inval_tss$/;"	l
global	./kernel/kernel.asm	/^global	nmi$/;"	l
global	./kernel/kernel.asm	/^global	overflow$/;"	l
global	./kernel/kernel.asm	/^global	page_fault$/;"	l
global	./kernel/kernel.asm	/^global	segment_not_present$/;"	l
global	./kernel/kernel.asm	/^global	single_step_exception$/;"	l
global	./kernel/kernel.asm	/^global	stack_exception$/;"	l
global	./kernel/kernel.asm	/^global _start	; 导出 _start$/;"	l
global	./kernel/kernel.asm	/^global restart$/;"	l
global	./kernel/kernel.asm	/^global sys_call$/;"	l
global	./kernel/syscall.asm	/^global	printx$/;"	l
global	./kernel/syscall.asm	/^global	sendrec$/;"	l
global	./lib/kliba.asm	/^global	disable_int$/;"	l
global	./lib/kliba.asm	/^global	disable_irq$/;"	l
global	./lib/kliba.asm	/^global	disp_color_str$/;"	l
global	./lib/kliba.asm	/^global	disp_str$/;"	l
global	./lib/kliba.asm	/^global	enable_int$/;"	l
global	./lib/kliba.asm	/^global	enable_irq$/;"	l
global	./lib/kliba.asm	/^global	glitter$/;"	l
global	./lib/kliba.asm	/^global	in_byte$/;"	l
global	./lib/kliba.asm	/^global	out_byte$/;"	l
global	./lib/kliba.asm	/^global	port_read$/;"	l
global	./lib/kliba.asm	/^global	port_write$/;"	l
global	./lib/string.asm	/^global	memcpy$/;"	l
global	./lib/string.asm	/^global	memset$/;"	l
global	./lib/string.asm	/^global  strcpy$/;"	l
global	./lib/string.asm	/^global  strlen$/;"	l
gs	./include/proc.h	/^	u32	gs;		\/* ┓						│			*\/$/;"	m	struct:stackframe
gs	./include/protect.h	/^	u32	gs;$/;"	m	struct:tss
has_int_msg	./include/proc.h	/^	int has_int_msg;           \/**$/;"	m	struct:proc
hd_cmd	./include/hd.h	/^struct hd_cmd {$/;"	s
hd_cmd_out	./kernel/hd.c	/^PRIVATE void hd_cmd_out(struct hd_cmd* cmd)$/;"	f
hd_handler	./kernel/hd.c	/^PUBLIC void hd_handler(int irq)$/;"	f
hd_identify	./kernel/hd.c	/^PRIVATE void hd_identify(int drive)$/;"	f
hd_info	./include/hd.h	/^struct hd_info$/;"	s
hd_info	./kernel/hd.c	/^PRIVATE	struct hd_info	hd_info[1];$/;"	v	typeref:struct:hd_info
hd_open	./kernel/hd.c	/^PRIVATE void hd_open(int device)$/;"	f
hd_status	./kernel/hd.c	/^PRIVATE	u8		hd_status;$/;"	v
hdbuf	./kernel/hd.c	/^PRIVATE	u8		hdbuf[SECTOR_SIZE * 2];$/;"	v
hwint00	./kernel/kernel.asm	/^hwint00:		; Interrupt routine for irq 0 (the clock).$/;"	l
hwint01	./kernel/kernel.asm	/^hwint01:		; Interrupt routine for irq 1 (keyboard)$/;"	l
hwint02	./kernel/kernel.asm	/^hwint02:		; Interrupt routine for irq 2 (cascade!)$/;"	l
hwint03	./kernel/kernel.asm	/^hwint03:		; Interrupt routine for irq 3 (second serial)$/;"	l
hwint04	./kernel/kernel.asm	/^hwint04:		; Interrupt routine for irq 4 (first serial)$/;"	l
hwint05	./kernel/kernel.asm	/^hwint05:		; Interrupt routine for irq 5 (XT winchester)$/;"	l
hwint06	./kernel/kernel.asm	/^hwint06:		; Interrupt routine for irq 6 (floppy)$/;"	l
hwint07	./kernel/kernel.asm	/^hwint07:		; Interrupt routine for irq 7 (printer)$/;"	l
hwint08	./kernel/kernel.asm	/^hwint08:		; Interrupt routine for irq 8 (realtime clock).$/;"	l
hwint09	./kernel/kernel.asm	/^hwint09:		; Interrupt routine for irq 9 (irq 2 redirected)$/;"	l
hwint10	./kernel/kernel.asm	/^hwint10:		; Interrupt routine for irq 10$/;"	l
hwint11	./kernel/kernel.asm	/^hwint11:		; Interrupt routine for irq 11$/;"	l
hwint12	./kernel/kernel.asm	/^hwint12:		; Interrupt routine for irq 12$/;"	l
hwint13	./kernel/kernel.asm	/^hwint13:		; Interrupt routine for irq 13 (FPU exception)$/;"	l
hwint14	./kernel/kernel.asm	/^hwint14:		; Interrupt routine for irq 14 (AT winchester)$/;"	l
hwint15	./kernel/kernel.asm	/^hwint15:		; Interrupt routine for irq 15$/;"	l
i2a	./kernel/vsprintf.c	/^PRIVATE char* i2a(int val, int base, char ** ps)$/;"	f
i_cnt	./include/fs.h	/^	int	i_cnt;		\/**< How many procs share this inode  *\/$/;"	m	struct:inode
i_dev	./include/fs.h	/^	int	i_dev;$/;"	m	struct:inode
i_mode	./include/fs.h	/^	u32	i_mode;		\/**< Accsess mode. Unused currently *\/$/;"	m	struct:inode
i_nr_sects	./include/fs.h	/^	u32	i_nr_sects;	\/**< How many sectors the file occupies *\/$/;"	m	struct:inode
i_num	./include/fs.h	/^	int	i_num;		\/**< inode nr.  *\/$/;"	m	struct:inode
i_size	./include/fs.h	/^	u32	i_size;		\/**< File size *\/$/;"	m	struct:inode
i_start_sect	./include/fs.h	/^	u32	i_start_sect;	\/**< The first sector of the data *\/$/;"	m	struct:inode
idt	./include/global.h	/^EXTERN	struct gate		idt[IDT_SIZE];$/;"	v	typeref:struct:gate
idt_ptr	./include/global.h	/^EXTERN	u8			idt_ptr[6];	\/* 0~15:Limit  16~47:Base *\/$/;"	v
in_buf	./include/tty.h	/^	u32	in_buf[TTY_IN_BYTES];	\/* TTY 输入缓冲区 *\/$/;"	m	struct:s_tty
in_byte	./lib/kliba.asm	/^in_byte:$/;"	l
in_process	./kernel/tty.c	/^PUBLIC void in_process(TTY* p_tty, u32 key)$/;"	f
inbuf_count	./include/tty.h	/^	int	inbuf_count;		\/* 缓冲区中已经填充了多少 *\/$/;"	m	struct:s_tty
inc	./boot/boot.asm	/^	inc	di$/;"	d
inc	./boot/loader.asm	/^	inc	di$/;"	d
inform_int	./kernel/proc.c	/^PUBLIC void inform_int(int task_nr)$/;"	f
init_8259A	./kernel/i8259.c	/^PUBLIC void init_8259A()$/;"	f
init_clock	./kernel/clock.c	/^PUBLIC void init_clock()$/;"	f
init_descriptor	./kernel/protect.c	/^PRIVATE void init_descriptor(struct descriptor * p_desc, u32 base, u32 limit, u16 attribute)$/;"	f
init_hd	./kernel/hd.c	/^PRIVATE void init_hd()$/;"	f
init_idt_desc	./kernel/protect.c	/^PUBLIC void init_idt_desc(unsigned char vector, u8 desc_type, int_handler handler, unsigned char privilege)$/;"	f
init_keyboard	./kernel/keyboard.c	/^PUBLIC void init_keyboard()$/;"	f
init_prot	./kernel/protect.c	/^PUBLIC void init_prot()$/;"	f
init_screen	./kernel/console.c	/^PUBLIC void init_screen(TTY* p_tty)$/;"	f
init_tty	./kernel/tty.c	/^PRIVATE void init_tty(TTY* p_tty)$/;"	f
initial_eip	./include/proc.h	/^	task_f	initial_eip;$/;"	m	struct:task
inode	./include/fs.h	/^struct inode {$/;"	s
inode_isize_off	./include/fs.h	/^	u32	inode_isize_off;  \/**< Offset of `struct inode::i_size' *\/$/;"	m	struct:super_block
inode_size	./include/fs.h	/^	u32	inode_size;       \/**< INODE_SIZE *\/$/;"	m	struct:super_block
inode_start_off	./include/fs.h	/^	u32	inode_start_off;  \/**< Offset of `struct inode::i_start_sect' *\/$/;"	m	struct:super_block
int_handler	./include/type.h	/^typedef	void	(*int_handler)	();$/;"	t
interrupt_wait	./kernel/hd.c	/^PRIVATE void interrupt_wait()$/;"	f
inval_opcode	./kernel/kernel.asm	/^inval_opcode:$/;"	l
inval_tss	./kernel/kernel.asm	/^inval_tss:$/;"	l
iobase	./include/protect.h	/^	u16	iobase;	\/* I\/O位图基址大于或等于TSS段界限，就表示没有I\/O许可位图 *\/$/;"	m	struct:tss
irq_handler	./include/type.h	/^typedef	void	(*irq_handler)	(int irq);$/;"	t
irq_table	./kernel/global.c	/^PUBLIC	irq_handler	irq_table[NR_IRQ];$/;"	v
is_current_console	./kernel/console.c	/^PUBLIC int is_current_console(CONSOLE* p_con)$/;"	f
is_special	./include/const.h	260;"	d
itoa	./lib/klib.c	/^PUBLIC char * itoa(char * str, int num)\/* 数字前面的 0 不被显示出来, 比如 0000B800 被显示成 B800 *\/$/;"	f
k_reenter	./include/global.h	/^EXTERN	u32	k_reenter;$/;"	v
kb_ack	./kernel/keyboard.c	/^PRIVATE void kb_ack()$/;"	f
kb_in	./kernel/keyboard.c	/^PRIVATE KB_INPUT	kb_in;$/;"	v
kb_wait	./kernel/keyboard.c	/^PRIVATE void kb_wait()	\/* 等待 8042 的输入缓冲区空 *\/$/;"	f
kernel_esp	./include/proc.h	/^	u32	kernel_esp;	\/* <- 'popad' will ignore it			│			*\/$/;"	m	struct:stackframe
kernel_main	./kernel/main.c	/^PUBLIC int kernel_main()$/;"	f
keyboard_handler	./kernel/keyboard.c	/^PUBLIC void keyboard_handler(int irq)$/;"	f
keyboard_read	./kernel/keyboard.c	/^PUBLIC void keyboard_read(TTY* p_tty)$/;"	f
keymap	./include/keymap.h	/^u32 keymap[NR_SCAN_CODES * MAP_COLS] = {$/;"	v
lba_high	./include/hd.h	/^	u8	lba_high;$/;"	m	struct:hd_cmd
lba_low	./include/hd.h	/^	u8	lba_low;$/;"	m	struct:hd_cmd
lba_mid	./include/hd.h	/^	u8	lba_mid;$/;"	m	struct:hd_cmd
ldt	./include/protect.h	/^	u32	ldt;$/;"	m	struct:tss
ldt_seg_linear	./kernel/proc.c	/^PUBLIC int ldt_seg_linear(struct proc* p, int idx)$/;"	f
ldt_sel	./include/proc.h	/^	u16 ldt_sel;               \/* gdt selector giving ldt base and limit *\/$/;"	m	struct:proc
ldts	./include/proc.h	/^	struct descriptor ldts[LDT_SIZE]; \/* local descs for code and data *\/$/;"	m	struct:proc	typeref:struct:proc::descriptor
limit_high_attr2	./include/protect.h	/^	u8	limit_high_attr2;	\/* G(1) D(1) 0(1) AVL(1) LimitHigh(4) *\/$/;"	m	struct:descriptor
limit_low	./include/protect.h	/^	u16	limit_low;		\/* Limit *\/$/;"	m	struct:descriptor
logical	./include/hd.h	/^	struct part_info	logical[NR_SUB_PER_DRIVE];$/;"	m	struct:hd_info	typeref:struct:hd_info::part_info
m1	./include/type.h	/^		struct mess1 m1;$/;"	m	union:__anon1::__anon2	typeref:struct:__anon1::__anon2::mess1
m1i1	./include/type.h	/^	int m1i1;$/;"	m	struct:mess1
m1i2	./include/type.h	/^	int m1i2;$/;"	m	struct:mess1
m1i3	./include/type.h	/^	int m1i3;$/;"	m	struct:mess1
m1i4	./include/type.h	/^	int m1i4;$/;"	m	struct:mess1
m2	./include/type.h	/^		struct mess2 m2;$/;"	m	union:__anon1::__anon2	typeref:struct:__anon1::__anon2::mess2
m2p1	./include/type.h	/^	void* m2p1;$/;"	m	struct:mess2
m2p2	./include/type.h	/^	void* m2p2;$/;"	m	struct:mess2
m2p3	./include/type.h	/^	void* m2p3;$/;"	m	struct:mess2
m2p4	./include/type.h	/^	void* m2p4;$/;"	m	struct:mess2
m3	./include/type.h	/^		struct mess3 m3;$/;"	m	union:__anon1::__anon2	typeref:struct:__anon1::__anon2::mess3
m3i1	./include/type.h	/^	int	m3i1;$/;"	m	struct:mess3
m3i2	./include/type.h	/^	int	m3i2;$/;"	m	struct:mess3
m3i3	./include/type.h	/^	int	m3i3;$/;"	m	struct:mess3
m3i4	./include/type.h	/^	int	m3i4;$/;"	m	struct:mess3
m3l1	./include/type.h	/^	u64	m3l1;$/;"	m	struct:mess3
m3l2	./include/type.h	/^	u64	m3l2;$/;"	m	struct:mess3
m3p1	./include/type.h	/^	void*	m3p1;$/;"	m	struct:mess3
m3p2	./include/type.h	/^	void*	m3p2;$/;"	m	struct:mess3
magic	./include/fs.h	/^	u32	magic;		  \/**< Magic number *\/$/;"	m	struct:super_block
max	./include/const.h	31;"	d
memcpy	./lib/string.asm	/^memcpy:$/;"	l
memset	./lib/string.asm	/^memset:$/;"	l
mess1	./include/type.h	/^struct mess1 {$/;"	s
mess2	./include/type.h	/^struct mess2 {$/;"	s
mess3	./include/type.h	/^struct mess3 {$/;"	s
milli_delay	./kernel/clock.c	/^PUBLIC void milli_delay(int milli_sec)$/;"	f
min	./include/const.h	32;"	d
msg_receive	./kernel/proc.c	/^PRIVATE int msg_receive(struct proc* current, int src, MESSAGE* m)$/;"	f
msg_send	./kernel/proc.c	/^PRIVATE int msg_send(struct proc* current, int dest, MESSAGE* m)$/;"	f
msgtype	./include/const.h	/^enum msgtype {$/;"	g
mul	./boot/boot.asm	/^	mul	dh$/;"	d
mul	./boot/loader.asm	/^	mul	dh$/;"	d
n_1st_sect	./include/fs.h	/^	u32	n_1st_sect;	  \/**< Number of the 1st data sector *\/$/;"	m	struct:super_block
name	./include/proc.h	/^	char	name[32];$/;"	m	struct:task
name	./include/proc.h	/^	char name[16];		   \/* name of the process *\/$/;"	m	struct:proc
next_sending	./include/proc.h	/^	struct proc * next_sending;\/**$/;"	m	struct:proc	typeref:struct:proc::proc
nmi	./kernel/kernel.asm	/^nmi:$/;"	l
nr_current_console	./include/global.h	/^EXTERN	int	nr_current_console;$/;"	v
nr_imap_sects	./include/fs.h	/^	u32	nr_imap_sects;	  \/**< How many inode-map sectors *\/$/;"	m	struct:super_block
nr_inode_sects	./include/fs.h	/^	u32	nr_inode_sects;   \/**< How many inode sectors *\/$/;"	m	struct:super_block
nr_inodes	./include/fs.h	/^	u32	nr_inodes;	  \/**< How many inodes *\/$/;"	m	struct:super_block
nr_sects	./include/fs.h	/^	u32	nr_sects;	  \/**< How many sectors (including bit maps) *\/$/;"	m	struct:super_block
nr_sects	./include/hd.h	/^	u32 nr_sects;		\/**$/;"	m	struct:part_ent
nr_smap_sects	./include/fs.h	/^	u32	nr_smap_sects;	  \/**< How many sector-map sectors *\/$/;"	m	struct:super_block
nr_tty	./include/proc.h	/^	int nr_tty;$/;"	m	struct:proc
num_lock	./kernel/keyboard.c	/^PRIVATE	int	num_lock;	\/* Num Lock	 *\/$/;"	v
offset_high	./include/protect.h	/^	u16	offset_high;	\/* Offset High *\/$/;"	m	struct:gate
offset_low	./include/protect.h	/^	u16	offset_low;	\/* Offset Low *\/$/;"	m	struct:gate
open_cnt	./include/hd.h	/^	int			open_cnt;$/;"	m	struct:hd_info
org	./boot/loader.asm	/^org  0100h$/;"	l
original_addr	./include/console.h	/^	unsigned int	original_addr;		\/* 当前控制台对应显存位置 *\/$/;"	m	struct:s_console
out_byte	./lib/kliba.asm	/^out_byte:$/;"	l
out_char	./kernel/console.c	/^PUBLIC void out_char(CONSOLE* p_con, char ch)$/;"	f
overflow	./kernel/kernel.asm	/^overflow:$/;"	l
p_console	./include/tty.h	/^	struct s_console *	p_console;$/;"	m	struct:s_tty	typeref:struct:s_tty::s_console
p_flags	./include/proc.h	/^	int  p_flags;              \/**$/;"	m	struct:proc
p_head	./include/keyboard.h	/^	char*	p_head;			\/* 指向缓冲区中下一个空闲位置 *\/$/;"	m	struct:s_kb
p_inbuf_head	./include/tty.h	/^	u32*	p_inbuf_head;		\/* 指向缓冲区中下一个空闲位置 *\/$/;"	m	struct:s_tty
p_inbuf_tail	./include/tty.h	/^	u32*	p_inbuf_tail;		\/* 指向键盘任务应处理的键值 *\/$/;"	m	struct:s_tty
p_msg	./include/proc.h	/^	MESSAGE * p_msg;$/;"	m	struct:proc
p_proc_ready	./include/global.h	/^EXTERN	struct proc*	p_proc_ready;$/;"	v	typeref:struct:proc
p_recvfrom	./include/proc.h	/^	int p_recvfrom;$/;"	m	struct:proc
p_sendto	./include/proc.h	/^	int p_sendto;$/;"	m	struct:proc
p_tail	./include/keyboard.h	/^	char*	p_tail;			\/* 指向键盘任务应处理的字节 *\/$/;"	m	struct:s_kb
page_fault	./kernel/kernel.asm	/^page_fault:$/;"	l
panic	./kernel/main.c	/^PUBLIC void panic(const char *fmt, ...)$/;"	f
part_ent	./include/hd.h	/^struct part_ent {$/;"	s
part_info	./include/hd.h	/^struct part_info {$/;"	s
partition	./kernel/hd.c	/^PRIVATE void partition(int device, int style)$/;"	f
phys_copy	./include/string.h	18;"	d
phys_set	./include/string.h	19;"	d
pid	./include/proc.h	/^	u32 pid;                   \/* process id passed in from MM *\/$/;"	m	struct:proc
pop	./boot/boot.asm	/^	pop	dx$/;"	d
pop	./boot/loader.asm	/^	pop	dx$/;"	d
pop	./kernel/kernel.asm	/^	pop	ds$/;"	d
port_read	./lib/kliba.asm	/^port_read:$/;"	l
port_write	./lib/kliba.asm	/^port_write:$/;"	l
primary	./include/hd.h	/^	struct part_info	primary[NR_PRIM_PER_DRIVE];$/;"	m	struct:hd_info	typeref:struct:hd_info::part_info
print_hdinfo	./kernel/hd.c	/^PRIVATE void print_hdinfo(struct hd_info * hdi)$/;"	f
print_identify_info	./kernel/hd.c	/^PRIVATE void print_identify_info(u16* hdinfo)$/;"	f
printf	./kernel/printf.c	/^int printf(const char *fmt, ...)$/;"	f
printl	./include/proto.h	80;"	d
printx	./kernel/syscall.asm	/^printx:$/;"	l
priority	./include/proc.h	/^        int priority;$/;"	m	struct:proc
proc	./include/proc.h	/^struct proc {$/;"	s
proc2pid	./include/proc.h	75;"	d
proc_table	./kernel/global.c	/^PUBLIC	struct proc	proc_table[NR_TASKS + NR_PROCS];$/;"	v	typeref:struct:proc
push	./boot/boot.asm	/^	push	dx$/;"	d
push	./boot/loader.asm	/^	push	dx$/;"	d
push	./kernel/kernel.asm	/^        push    ds      ;  |$/;"	d
put_irq_handler	./kernel/i8259.c	/^PUBLIC void put_irq_handler(int irq, irq_handler handler)$/;"	f
put_key	./kernel/tty.c	/^PRIVATE void put_key(TTY* p_tty, u32 key)$/;"	f
q_sending	./include/proc.h	/^	struct proc * q_sending;   \/**$/;"	m	struct:proc	typeref:struct:proc::proc
regs	./include/proc.h	/^	struct stackframe regs;    \/* process registers saved in stack frame *\/$/;"	m	struct:proc	typeref:struct:proc::stackframe
reset_msg	./kernel/proc.c	/^PUBLIC void reset_msg(MESSAGE* p)$/;"	f
restart	./kernel/kernel.asm	/^restart:$/;"	l
restart_reenter	./kernel/kernel.asm	/^restart_reenter:$/;"	l
retaddr	./include/proc.h	/^	u32	retaddr;	\/* return address for assembly code save()	│			*\/$/;"	m	struct:stackframe
root_inode	./include/fs.h	/^	u32	root_inode;       \/**< Inode nr of root directory *\/$/;"	m	struct:super_block
s_console	./include/console.h	/^typedef struct s_console$/;"	s
s_kb	./include/keyboard.h	/^typedef struct s_kb {$/;"	s
s_tty	./include/tty.h	/^typedef struct s_tty$/;"	s
save	./kernel/kernel.asm	/^save:$/;"	l
sb_dev	./include/fs.h	/^	int	sb_dev; 	\/**< the super block's home device *\/$/;"	m	struct:super_block
schedule	./kernel/proc.c	/^PUBLIC void schedule()$/;"	f
scroll_lock	./kernel/keyboard.c	/^PRIVATE	int	scroll_lock;	\/* Scroll Lock	 *\/$/;"	v
scroll_screen	./kernel/console.c	/^PUBLIC void scroll_screen(CONSOLE* p_con, int direction)$/;"	f
seg2phys	./kernel/protect.c	/^PUBLIC u32 seg2phys(u16 seg)$/;"	f
segment_not_present	./kernel/kernel.asm	/^segment_not_present:$/;"	l
select_console	./kernel/console.c	/^PUBLIC void select_console(int nr_console)	\/* 0 ~ (NR_CONSOLES - 1) *\/$/;"	f
selector	./include/protect.h	/^	u16	selector;	\/* Selector *\/$/;"	m	struct:gate
send_recv	./kernel/proc.c	/^PUBLIC int send_recv(int function, int src_dest, MESSAGE* msg)$/;"	f
sendrec	./kernel/syscall.asm	/^sendrec:$/;"	l
set_cursor	./kernel/console.c	/^PRIVATE void set_cursor(unsigned int position)$/;"	f
set_leds	./kernel/keyboard.c	/^PRIVATE void set_leds()$/;"	f
set_video_start_addr	./kernel/console.c	/^PRIVATE void set_video_start_addr(u32 addr)$/;"	f
shift_l	./kernel/keyboard.c	/^PRIVATE	int	shift_l;	\/* l shift state *\/$/;"	v
shift_r	./kernel/keyboard.c	/^PRIVATE	int	shift_r;	\/* r shift state *\/$/;"	v
single_step_exception	./kernel/kernel.asm	/^single_step_exception:$/;"	l
size	./include/hd.h	/^	u32	size;	\/* how many sectors in this partition *\/$/;"	m	struct:part_info
source	./include/type.h	/^	int source;$/;"	m	struct:__anon1
spin	./lib/misc.c	/^PUBLIC void spin(char * func_name)$/;"	f
sprintf	./kernel/vsprintf.c	/^int sprintf(char *buf, const char *fmt, ...)$/;"	f
spurious_irq	./kernel/i8259.c	/^PUBLIC void spurious_irq(int irq)$/;"	f
ss	./include/proc.h	/^	u32	ss;		\/*  ┛						┷High			*\/$/;"	m	struct:stackframe
ss	./include/protect.h	/^	u32	ss;$/;"	m	struct:tss
ss0	./include/protect.h	/^	u32	ss0;		\/*   "   segment  "  "    "        "     *\/$/;"	m	struct:tss
ss1	./include/protect.h	/^	u32	ss1;$/;"	m	struct:tss
ss2	./include/protect.h	/^	u32	ss2;$/;"	m	struct:tss
stack_exception	./kernel/kernel.asm	/^stack_exception:$/;"	l
stackframe	./include/proc.h	/^struct stackframe {	\/* proc_ptr points here				↑ Low			*\/$/;"	s
stacksize	./include/proc.h	/^	int	stacksize;$/;"	m	struct:task
start_cyl	./include/hd.h	/^	u8 start_cyl;		\/**$/;"	m	struct:part_ent
start_head	./include/hd.h	/^	u8 start_head;		\/**$/;"	m	struct:part_ent
start_sect	./include/hd.h	/^	u32 start_sect;	\/**$/;"	m	struct:part_ent
start_sector	./include/hd.h	/^	u8 start_sector;	\/**$/;"	m	struct:part_ent
strcpy	./lib/string.asm	/^strcpy:$/;"	l
strlen	./lib/string.asm	/^strlen:$/;"	l
super_block	./include/fs.h	/^struct super_block {$/;"	s
sys_call	./kernel/kernel.asm	/^sys_call:$/;"	l
sys_call_table	./kernel/global.c	/^PUBLIC	system_call	sys_call_table[NR_SYS_CALL] = {sys_printx,$/;"	v
sys_id	./include/hd.h	/^	u8 sys_id;		\/**$/;"	m	struct:part_ent
sys_printx	./kernel/tty.c	/^PUBLIC int sys_printx(int _unused1, int _unused2, char* s, struct proc* p_proc)$/;"	f
sys_sendrec	./kernel/proc.c	/^PUBLIC int sys_sendrec(int function, int src_dest, MESSAGE* m, struct proc* p)$/;"	f
system_call	./include/type.h	/^typedef void*	system_call;$/;"	t
szMemChkTitle	./boot/loader.asm	/^szMemChkTitle		equ	BaseOfLoaderPhyAddr + _szMemChkTitle$/;"	d
szRAMSize	./boot/loader.asm	/^szRAMSize		equ	BaseOfLoaderPhyAddr + _szRAMSize$/;"	d
szReturn	./boot/loader.asm	/^szReturn		equ	BaseOfLoaderPhyAddr + _szReturn$/;"	d
task	./include/proc.h	/^struct task {$/;"	s
task_f	./include/type.h	/^typedef	void	(*task_f)	();$/;"	t
task_fs	./fs/main.c	/^PUBLIC void task_fs()$/;"	f
task_hd	./kernel/hd.c	/^PUBLIC void task_hd()$/;"	f
task_stack	./kernel/global.c	/^PUBLIC	char		task_stack[STACK_SIZE_TOTAL];$/;"	v
task_sys	./kernel/systask.c	/^PUBLIC void task_sys()$/;"	f
task_table	./kernel/global.c	/^PUBLIC	struct task	task_table[NR_TASKS] = {$/;"	v	typeref:struct:task
task_tty	./kernel/tty.c	/^PUBLIC void task_tty()$/;"	f
ticks	./include/global.h	/^EXTERN	int	ticks;$/;"	v
ticks	./include/proc.h	/^        int ticks;                 \/* remained ticks *\/$/;"	m	struct:proc
times	./boot/boot.asm	/^times 	510-($-$$)	db	0	; 填充剩下的空间，使生成的二进制代码恰好为512字节$/;"	l
trap	./include/protect.h	/^	u16	trap;$/;"	m	struct:tss
tss	./include/global.h	/^EXTERN	struct tss	tss;$/;"	v	typeref:struct:tss
tss	./include/protect.h	/^struct tss {$/;"	s
tty_do_read	./kernel/tty.c	/^PRIVATE void tty_do_read(TTY* p_tty)$/;"	f
tty_do_write	./kernel/tty.c	/^PRIVATE void tty_do_write(TTY* p_tty)$/;"	f
tty_table	./kernel/global.c	/^PUBLIC	TTY		tty_table[NR_CONSOLES];$/;"	v
tty_write	./kernel/tty.c	/^PUBLIC void tty_write(TTY* p_tty, char* buf, int len)$/;"	f
type	./include/type.h	/^	int type;$/;"	m	struct:__anon1
u	./include/type.h	/^	} u;$/;"	m	struct:__anon1	typeref:union:__anon1::__anon2
u16	./include/type.h	/^typedef	unsigned short		u16;$/;"	t
u32	./include/type.h	/^typedef	unsigned int		u32;$/;"	t
u64	./include/type.h	/^typedef	unsigned long long	u64;$/;"	t
u8	./include/type.h	/^typedef	unsigned char		u8;$/;"	t
unblock	./kernel/proc.c	/^PRIVATE void unblock(struct proc* p)$/;"	f
user_proc_table	./kernel/global.c	/^PUBLIC	struct task	user_proc_table[NR_PROCS] = {$/;"	v	typeref:struct:task
v_mem_limit	./include/console.h	/^	unsigned int	v_mem_limit;		\/* 当前控制台占的显存大小 *\/$/;"	m	struct:s_console
va2la	./kernel/proc.c	/^PUBLIC void* va2la(int pid, void* va)$/;"	f
va_list	./include/type.h	/^typedef	char *			va_list;$/;"	t
vir2phys	./include/protect.h	154;"	d
vsprintf	./kernel/vsprintf.c	/^PUBLIC int vsprintf(char *buf, const char *fmt, va_list args)$/;"	f
wRootDirSizeForLoop	./boot/boot.asm	/^wRootDirSizeForLoop	dw	RootDirSectors	; Root Directory 占用的扇区数, 在循环中会递减至零.$/;"	d
wRootDirSizeForLoop	./boot/loader.asm	/^wRootDirSizeForLoop	dw	RootDirSectors	; Root Directory 占用的扇区数$/;"	d
wSectorNo	./boot/boot.asm	/^wSectorNo		dw	0		; 要读取的扇区号$/;"	d
wSectorNo	./boot/loader.asm	/^wSectorNo		dw	0		; 要读取的扇区号$/;"	d
waitfor	./kernel/hd.c	/^PRIVATE int waitfor(int mask, int val, int timeout)$/;"	f
